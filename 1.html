<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>CircuitPro Advanced | Complete Digital Electronics Suite</title>    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">    <style>        * {            margin: 0;            padding: 0;            box-sizing: border-box;        }        :root {            --primary-50: #f0f9ff;            --primary-100: #e0f2fe;            --primary-200: #bae6fd;            --primary-500: #0ea5e9;            --primary-600: #0284c7;            --primary-700: #0369a1;            --primary-900: #0c4a6e;            --accent-blue: #3b82f6;            --accent-purple: #8b5cf6;            --accent-green: #10b981;            --accent-orange: #f59e0b;            --accent-red: #ef4444;            --accent-pink: #ec4899;            --accent-cyan: #06b6d4;            --bg-primary: #0a0f1c;            --bg-secondary: #111827;            --bg-tertiary: #1f2937;            --bg-quaternary: #374151;            --bg-surface: #1e293b;            --bg-elevated: #2d3748;            --text-primary: #ffffff;            --text-secondary: #e2e8f0;            --text-tertiary: #cbd5e1;            --text-muted: #94a3b8;            --border-subtle: #374151;            --border-default: #4b5563;            --border-strong: #6b7280;            --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.05);            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgba(0, 0, 0, 0.1);            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);            --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);            --gradient-secondary: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);            --gradient-accent: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);            --gradient-rainbow: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #f5576c 75%, #4facfe 100%);        }        body {            font-family: 'Inter', system-ui, -apple-system, sans-serif;            background: var(--bg-primary);            color: var(--text-primary);            overflow: hidden;            height: 100vh;            -webkit-font-smoothing: antialiased;            -moz-osx-font-smoothing: grayscale;            touch-action: none;        }        .app-container {            display: flex;            height: 100vh;            width: 100vw;        }        /* Enhanced Header - Fixed height and positioning */        .app-header {            position: fixed;            top: 0;            left: 0;            right: 0;            height: 80px;            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);            border-bottom: 1px solid var(--border-default);            display: flex;            align-items: center;            padding: 0 24px;            z-index: 1000;            box-shadow: var(--shadow-xl);            backdrop-filter: blur(20px) saturate(180%);            min-height: 80px;        }        .brand-section {            display: flex;            align-items: center;            gap: 16px;            flex: 1;            min-width: 0;        }        .logo-container {            position: relative;            width: 60px;            height: 60px;            background: var(--gradient-rainbow);            border-radius: 16px;            display: flex;            align-items: center;            justify-content: center;            box-shadow: var(--shadow-lg);            flex-shrink: 0;        }        .logo-icon {            font-size: 28px;            color: white;            font-weight: bold;        }        .brand-info {            display: flex;            flex-direction: column;            gap: 4px;            min-width: 0;        }        .app-name {            font-size: 28px;            font-weight: 800;            background: var(--gradient-rainbow);            -webkit-background-clip: text;            -webkit-text-fill-color: transparent;            background-clip: text;            letter-spacing: -0.02em;            white-space: nowrap;        }        .app-tagline {            font-size: 14px;            color: var(--text-tertiary);            font-weight: 500;            white-space: nowrap;        }        .header-controls {            display: flex;            align-items: center;            gap: 12px;            flex-shrink: 0;        }        .mode-switcher {            display: flex;            background: var(--bg-elevated);            border: 1px solid var(--border-subtle);            border-radius: 12px;            padding: 4px;            box-shadow: var(--shadow-sm);        }        .mode-btn {            padding: 8px 16px;            border: none;            background: transparent;            color: var(--text-secondary);            border-radius: 8px;            cursor: pointer;            font-size: 13px;            font-weight: 600;            transition: all 0.2s;            display: flex;            align-items: center;            gap: 6px;            white-space: nowrap;        }        .mode-btn.active {            background: var(--accent-blue);            color: white;            box-shadow: var(--shadow-sm);        }        .status-indicators {            display: flex;            gap: 8px;        }        .status-badge {            display: flex;            align-items: center;            gap: 6px;            padding: 8px 12px;            background: var(--bg-elevated);            border: 1px solid var(--border-subtle);            border-radius: 8px;            font-size: 12px;            font-weight: 500;            color: var(--text-secondary);            box-shadow: var(--shadow-sm);            white-space: nowrap;        }        /* Sidebar - Fixed width and positioning */        .sidebar {            position: fixed;            left: 0;            top: 80px;            width: 380px;            height: calc(100vh - 80px);            background: var(--bg-secondary);            border-right: 1px solid var(--border-default);            overflow: hidden;            display: flex;            flex-direction: column;            box-shadow: var(--shadow-xl);            z-index: 900;            transition: transform 0.3s ease;        }        .sidebar-tabs {            display: flex;            background: var(--bg-tertiary);            border-bottom: 1px solid var(--border-default);            flex-shrink: 0;        }        .sidebar-tab {            flex: 1;            padding: 16px 12px;            background: transparent;            border: none;            color: var(--text-secondary);            cursor: pointer;            font-size: 13px;            font-weight: 600;            transition: all 0.2s;            display: flex;            align-items: center;            justify-content: center;            gap: 6px;        }        .sidebar-tab.active {            background: var(--accent-blue);            color: white;        }        .sidebar-content {            flex: 1;            overflow-y: auto;            scrollbar-width: thin;            scrollbar-color: var(--border-default) transparent;        }        .sidebar-content::-webkit-scrollbar {            width: 6px;        }        .sidebar-content::-webkit-scrollbar-track {            background: transparent;        }        .sidebar-content::-webkit-scrollbar-thumb {            background: var(--border-default);            border-radius: 3px;        }        /* Component sections */        .component-section {            border-bottom: 1px solid var(--border-subtle);        }        .section-header {            padding: 20px 24px;            background: var(--bg-tertiary);            cursor: pointer;            display: flex;            justify-content: space-between;            align-items: center;            font-weight: 600;            font-size: 15px;            color: var(--text-primary);            transition: all 0.2s;            border-bottom: 1px solid var(--border-subtle);        }        .section-header:hover {            background: var(--bg-elevated);            color: var(--accent-blue);        }        .section-icon {            display: flex;            align-items: center;            gap: 12px;        }        .section-chevron {            transition: transform 0.2s;            color: var(--text-muted);            font-size: 14px;        }        .section-header.collapsed .section-chevron {            transform: rotate(-90deg);        }        .section-grid {            padding: 20px;            display: grid;            grid-template-columns: repeat(2, 1fr);            gap: 12px;            background: var(--bg-secondary);        }        .section-grid.collapsed {            display: none;        }        .component-card {            padding: 16px;            background: var(--bg-elevated);            border: 1px solid var(--border-subtle);            border-radius: 12px;            cursor: grab;            text-align: center;            transition: all 0.2s;            position: relative;            overflow: hidden;            box-shadow: var(--shadow-sm);            user-select: none;        }        .component-card:hover {            background: var(--bg-quaternary);            border-color: var(--accent-blue);            transform: translateY(-2px);            box-shadow: var(--shadow-md);        }        .component-card.dragging {            opacity: 0.5;            transform: rotate(5deg);        }        .component-icon {            font-size: 24px;            margin-bottom: 8px;            background: var(--gradient-accent);            -webkit-background-clip: text;            -webkit-text-fill-color: transparent;            background-clip: text;        }        .component-name {            font-size: 12px;            font-weight: 600;            color: var(--text-secondary);            letter-spacing: 0.02em;            text-transform: uppercase;        }        /* Boolean Algebra Tools */        .boolean-tools {            padding: 20px;        }        .tool-section {            margin-bottom: 24px;            background: var(--bg-elevated);            border-radius: 12px;            padding: 16px;            border: 1px solid var(--border-subtle);        }        .tool-title {            font-size: 16px;            font-weight: 600;            color: var(--text-primary);            margin-bottom: 12px;            display: flex;            align-items: center;            gap: 8px;        }        .expression-input {            width: 100%;            padding: 12px;            background: var(--bg-primary);            border: 1px solid var(--border-subtle);            border-radius: 8px;            color: var(--text-primary);            font-family: 'JetBrains Mono', monospace;            font-size: 14px;            margin-bottom: 12px;            transition: all 0.2s;        }        .expression-input:focus {            outline: none;            border-color: var(--accent-blue);            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);        }        .tool-btn {            padding: 8px 16px;            background: var(--accent-blue);            border: none;            border-radius: 6px;            color: white;            font-size: 13px;            font-weight: 500;            cursor: pointer;            transition: all 0.2s;            margin-right: 8px;            margin-bottom: 8px;        }        .tool-btn:hover {            background: var(--primary-700);            transform: translateY(-1px);        }        .result-area {            background: var(--bg-primary);            border: 1px solid var(--border-subtle);            border-radius: 8px;            padding: 12px;            font-family: 'JetBrains Mono', monospace;            font-size: 13px;            color: var(--text-secondary);            white-space: pre-wrap;            max-height: 200px;            overflow-y: auto;        }        /* K-Map Solver */        .kmap-container {            display: grid;            gap: 8px;            margin: 12px 0;        }        .kmap-2var {            grid-template-columns: auto 1fr 1fr;            grid-template-rows: auto 1fr 1fr;        }        .kmap-3var {            grid-template-columns: auto 1fr 1fr 1fr 1fr;            grid-template-rows: auto 1fr 1fr;        }        .kmap-4var {            grid-template-columns: auto 1fr 1fr 1fr 1fr;            grid-template-rows: auto 1fr 1fr 1fr 1fr;        }        .kmap-cell {            width: 40px;            height: 40px;            background: var(--bg-primary);            border: 1px solid var(--border-default);            display: flex;            align-items: center;            justify-content: center;            font-family: 'JetBrains Mono', monospace;            font-size: 14px;            cursor: pointer;            transition: all 0.2s;        }        .kmap-cell:hover {            background: var(--accent-blue);            color: white;        }        .kmap-cell.filled {            background: var(--accent-green);            color: white;        }        .kmap-label {            font-size: 12px;            font-weight: 600;            color: var(--text-secondary);            display: flex;            align-items: center;            justify-content: center;        }        /* Truth Table */        .truth-table {            width: 100%;            border-collapse: collapse;            margin: 12px 0;            font-family: 'JetBrains Mono', monospace;            font-size: 13px;        }        .truth-table th,        .truth-table td {            border: 1px solid var(--border-default);            padding: 8px 12px;            text-align: center;        }        .truth-table th {            background: var(--bg-elevated);            font-weight: 600;            color: var(--text-primary);        }        .truth-table td {            background: var(--bg-primary);            color: var(--text-secondary);        }        .truth-table tr:hover td {            background: var(--bg-elevated);        }        /* Main workspace - Adjusted for fixed sidebar */        .main-workspace {            flex: 1;            display: flex;            flex-direction: column;            margin-top: 80px;            margin-left: 380px; /* Fixed sidebar width */            min-width: 0;        }        .workspace-toolbar {            height: 72px;            background: var(--bg-secondary);            border-bottom: 1px solid var(--border-default);            display: flex;            align-items: center;            padding: 0 24px;            gap: 16px;            box-shadow: var(--shadow-sm);            overflow-x: auto;            flex-shrink: 0;        }        .toolbar-group {            display: flex;            align-items: center;            gap: 8px;            padding: 0 12px;            border-right: 1px solid var(--border-subtle);            flex-shrink: 0;        }        .toolbar-group:last-child {            border-right: none;        }        .toolbar-btn {            display: flex;            align-items: center;            gap: 8px;            padding: 10px 16px;            background: var(--bg-elevated);            border: 1px solid var(--border-subtle);            border-radius: 8px;            color: var(--text-secondary);            cursor: pointer;            font-size: 13px;            font-weight: 500;            transition: all 0.2s;            box-shadow: var(--shadow-xs);            white-space: nowrap;        }        .toolbar-btn:hover {            background: var(--accent-blue);            border-color: var(--accent-blue);            color: white;            transform: translateY(-1px);            box-shadow: var(--shadow-md);        }        .toolbar-btn.active {            background: var(--accent-blue);            border-color: var(--accent-blue);            color: white;        }        .toolbar-btn.primary {            background: var(--gradient-accent);            border-color: var(--accent-blue);            color: white;        }        /* Canvas */        .canvas-workspace {            flex: 1;            position: relative;            overflow: hidden;            background: var(--bg-primary);            background-image:                 radial-gradient(circle at 20% 20%, rgba(59, 130, 246, 0.08) 0%, transparent 50%),                radial-gradient(circle at 80% 80%, rgba(139, 92, 246, 0.08) 0%, transparent 50%),                radial-gradient(circle at 40% 60%, rgba(16, 185, 129, 0.05) 0%, transparent 50%);        }        .canvas {            position: absolute;            top: 0;            left: 0;            cursor: crosshair;            touch-action: none;        }        .grid-canvas {            position: absolute;            top: 0;            left: 0;            pointer-events: none;        }        /* Enhanced components */        .component {            position: absolute;            user-select: none;            cursor: move;            z-index: 10;            transition: all 0.1s;        }        .component.selected {            outline: 2px solid var(--accent-blue);            outline-offset: 4px;            box-shadow: 0 0 0 6px rgba(59, 130, 246, 0.2);        }        .wire {            position: absolute;            pointer-events: none;            z-index: 5;        }        .wire-preview {            position: absolute;            pointer-events: none;            z-index: 15;            stroke: var(--accent-blue);            stroke-width: 3;            stroke-dasharray: 12,8;            animation: wire-flow 2s linear infinite;            filter: drop-shadow(0 0 8px var(--accent-blue));        }        @keyframes wire-flow {            to { stroke-dashoffset: -20; }        }        .connection-point {            position: absolute;            width: 12px;            height: 12px;            background: var(--text-tertiary);            border: 2px solid var(--bg-primary);            border-radius: 50%;            cursor: pointer;            z-index: 20;            transform: translate(-50%, -50%);            transition: all 0.2s;            box-shadow: var(--shadow-sm);        }        .connection-point:hover {            background: var(--accent-blue);            border-color: var(--accent-blue);            transform: translate(-50%, -50%) scale(1.5);            box-shadow: 0 0 0 6px rgba(59, 130, 246, 0.3);        }        .connection-point.active {            background: var(--accent-green);            border-color: var(--accent-green);            box-shadow: 0 0 0 6px rgba(16, 185, 129, 0.3);        }        /* Properties Panel */        .properties-panel {            position: fixed;            right: 0;            top: 80px;            width: 320px;            height: calc(100vh - 80px);            background: var(--bg-secondary);            border-left: 1px solid var(--border-default);            box-shadow: var(--shadow-xl);            transform: translateX(100%);            transition: transform 0.3s ease;            z-index: 999;            overflow-y: auto;        }        .properties-panel.open {            transform: translateX(0);        }        .properties-header {            padding: 20px;            border-bottom: 1px solid var(--border-subtle);            background: var(--bg-tertiary);        }        .properties-title {            font-size: 18px;            font-weight: 600;            color: var(--text-primary);            margin-bottom: 4px;        }        .properties-subtitle {            font-size: 13px;            color: var(--text-tertiary);        }        .properties-content {            padding: 20px;        }        .property-group {            margin-bottom: 20px;        }        .property-label {            font-size: 14px;            font-weight: 500;            color: var(--text-secondary);            margin-bottom: 8px;            display: block;        }        .property-input {            width: 100%;            padding: 10px 12px;            background: var(--bg-primary);            border: 1px solid var(--border-subtle);            border-radius: 6px;            color: var(--text-primary);            font-size: 14px;            transition: all 0.2s;        }        .property-input:focus {            outline: none;            border-color: var(--accent-blue);            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);        }        .mobile-menu-btn {            display: none;            align-items: center;            justify-content: center;            width: 40px;            height: 40px;            background: var(--bg-elevated);            border: 1px solid var(--border-subtle);            border-radius: 8px;            color: var(--text-secondary);            cursor: pointer;            font-size: 18px;            transition: all 0.2s;        }        .mobile-menu-btn:hover {            background: var(--accent-blue);            color: white;        }        /* Toast notifications */        .toast {            position: fixed;            bottom: 20px;            right: 20px;            background: var(--bg-elevated);            color: var(--text-primary);            padding: 16px 20px;            border-radius: 12px;            border: 1px solid var(--border-default);            box-shadow: var(--shadow-xl);            z-index: 2000;            transform: translateX(100%);            transition: transform 0.3s ease;            max-width: 300px;        }        .toast.show {            transform: translateX(0);        }        .toast.success {            border-color: var(--accent-green);            background: linear-gradient(135deg, var(--bg-elevated) 0%, rgba(16, 185, 129, 0.1) 100%);        }        .toast.error {            border-color: var(--accent-red);            background: linear-gradient(135deg, var(--bg-elevated) 0%, rgba(239, 68, 68, 0.1) 100%);        }        /* Modal improvements */        .modal {            position: fixed;            top: 0;            left: 0;            width: 100%;            height: 100%;            background: rgba(0,0,0,0.8);            display: flex;            align-items: center;            justify-content: center;            z-index: 2000;            backdrop-filter: blur(8px);            opacity: 0;            transition: opacity 0.3s ease;        }        .modal.show {            opacity: 1;        }        .modal-content {            background: var(--bg-secondary);            padding: 32px;            border-radius: 16px;            border: 1px solid var(--border-default);            max-width: 90vw;            max-height: 90vh;            overflow-y: auto;            box-shadow: var(--shadow-2xl);            transform: scale(0.9);            transition: transform 0.3s ease;        }        .modal.show .modal-content {            transform: scale(1);        }        /* Loading states */        .loading {            opacity: 0.6;            pointer-events: none;            position: relative;        }        .loading::after {            content: '';            position: absolute;            top: 50%;            left: 50%;            width: 24px;            height: 24px;            margin: -12px 0 0 -12px;            border: 2px solid var(--accent-blue);            border-top-color: transparent;            border-radius: 50%;            animation: spin 1s linear infinite;        }        @keyframes spin {            to { transform: rotate(360deg); }        }        /* Animations */        @keyframes fadeIn {            from { opacity: 0; transform: translateY(10px); }            to { opacity: 1; transform: translateY(0); }        }        @keyframes slideIn {            from { transform: translateX(-100%); }            to { transform: translateX(0); }        }        .fade-in {            animation: fadeIn 0.3s ease-out;        }        .slide-in {            animation: slideIn 0.3s ease-out;        }        /* Responsive design improvements */        @media screen and (max-width: 1200px) {            .sidebar {                width: 320px;            }            .main-workspace {                margin-left: 320px;            }            .properties-panel {                width: 280px;            }            .app-name {                font-size: 24px;            }            .status-indicators {                gap: 6px;            }            .status-badge {                padding: 6px 10px;            }        }        @media screen and (max-width: 1024px) {            .app-header {                padding: 0 16px;            }            .brand-info .app-name {                font-size: 22px;            }            .brand-info .app-tagline {                font-size: 12px;            }            .mode-switcher {                gap: 4px;            }            .mode-btn {                padding: 6px 12px;                font-size: 12px;            }            .toolbar-btn {                padding: 8px 12px;                font-size: 12px;            }        }        @media screen and (max-width: 768px) {            .app-header {                height: 70px;                padding: 0 12px;            }                        .brand-info {                display: none;            }                        .sidebar {                width: 280px;                margin-top: 70px;                transform: translateX(-100%);                transition: transform 0.3s ease;                z-index: 998;            }                        .sidebar.open {                transform: translateX(0);            }                        .main-workspace {                margin-top: 70px;                margin-left: 0;            }                        .workspace-toolbar {                height: 60px;                padding: 0 12px;                gap: 8px;            }                        .toolbar-btn {                padding: 8px 12px;                font-size: 12px;            }                        .mobile-menu-btn {                display: flex !important;            }                        .status-indicators {                display: none;            }                        .mode-switcher {                display: none;            }        }        @media screen and (max-width: 640px) {            .section-grid {                grid-template-columns: 1fr;            }                        .app-name {                font-size: 20px;            }                        .header-controls {                gap: 8px;            }                        .toolbar-group {                padding: 0 8px;            }                        .toolbar-btn span {                display: none;            }                        .sidebar {                width: 100vw;            }        }        /* Sidebar visibility fixes */        .sidebar.sidebar-hidden {            transform: translateX(-100%);        }        .sidebar.sidebar-visible {            transform: translateX(0);        }        /* Ensure sidebar is always visible on desktop */        @media screen and (min-width: 769px) {            .sidebar {                transform: translateX(0) !important;                position: fixed;                left: 0;            }                        .main-workspace {                margin-left: 380px;            }        }        /* Fix zoom out visibility issues */        @media screen and (min-width: 769px) {            .sidebar,            .main-workspace,            .app-header {                min-width: 0;                max-width: none;            }                        .app-container {                min-width: 100vw;                width: 100vw;            }        }        /* Prevent sidebar from disappearing during zoom */        .sidebar {            will-change: transform;            backface-visibility: hidden;        }        /* Ensure proper layout at all zoom levels */        html {            overflow-x: hidden;        }        body {            min-width: 100vw;            width: 100vw;            position: relative;        }    </style></head><body>    <!-- Enhanced Header -->    <header class="app-header">        <button class="mobile-menu-btn" onclick="toggleSidebar()">            <i class="fas fa-bars"></i>        </button>                <div class="brand-section">            <div class="logo-container">                <i class="fas fa-microchip logo-icon"></i>            </div>            <div class="brand-info">                <h1 class="app-name">CircuitPro Advanced</h1>                <p class="app-tagline">Complete Digital Electronics Suite</p>            </div>        </div>                <div class="header-controls">            <div class="mode-switcher">                <button class="mode-btn active" data-mode="design">                    <i class="fas fa-drafting-compass"></i>                    Design                </button>                <button class="mode-btn" data-mode="simulate">                    <i class="fas fa-play"></i>                    Simulate                </button>                <button class="mode-btn" data-mode="analyze">                    <i class="fas fa-chart-line"></i>                    Analyze                </button>            </div>                        <div class="status-indicators">                <div class="status-badge">                    <i class="fas fa-search-plus"></i>                    <span>Zoom: <span id="zoom-level">100%</span></span>                </div>                <div class="status-badge">                    <i class="fas fa-microchip"></i>                    <span>Components: <span id="component-count">0</span></span>                </div>                <div class="status-badge">                    <i class="fas fa-project-diagram"></i>                    <span>Wires: <span id="wire-count">0</span></span>                </div>            </div>                        <button class="mobile-menu-btn" onclick="toggleProperties()" title="Properties">                <i class="fas fa-cog"></i>            </button>        </div>    </header>    <div class="app-container">        <!-- Advanced Sidebar -->        <aside class="sidebar sidebar-visible" id="sidebar">            <div class="sidebar-tabs">                <button class="sidebar-tab active" onclick="switchTab('components')">                    <i class="fas fa-microchip"></i>                    <span>Components</span>                </button>                <button class="sidebar-tab" onclick="switchTab('boolean')">                    <i class="fas fa-function"></i>                    <span>Boolean</span>                </button>                <button class="sidebar-tab" onclick="switchTab('kmap')">                    <i class="fas fa-th"></i>                    <span>K-Map</span>                </button>                <button class="sidebar-tab" onclick="switchTab('truth')">                    <i class="fas fa-table"></i>                    <span>Truth</span>                </button>            </div>                        <div class="sidebar-content">                <!-- Components Tab -->                <div id="components-tab" class="tab-content">                    <!-- Input Controls -->                    <div class="component-section">                        <div class="section-header" onclick="toggleSection('inputs')">                            <div class="section-icon">                                <i class="fas fa-toggle-on"></i>                                <span>Input Controls</span>                            </div>                            <i class="fas fa-chevron-down section-chevron" id="inputs-arrow"></i>                        </div>                        <div class="section-grid" id="inputs-content">                            <div class="component-card component-item" draggable="true" data-type="toggle" title="Toggle Switch">                                <div class="component-icon"><i class="fas fa-toggle-on"></i></div>                                <div class="component-name">Toggle</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="button" title="Push Button">                                <div class="component-icon"><i class="fas fa-circle"></i></div>                                <div class="component-name">Button</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="clock" title="Clock Generator">                                <div class="component-icon"><i class="fas fa-clock"></i></div>                                <div class="component-name">Clock</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="high" title="High Constant (1)">                                <div class="component-icon"><i class="fas fa-arrow-up"></i></div>                                <div class="component-name">High</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="low" title="Low Constant (0)">                                <div class="component-icon"><i class="fas fa-arrow-down"></i></div>                                <div class="component-name">Low</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="pulse" title="Pulse Generator">                                <div class="component-icon"><i class="fas fa-wave-square"></i></div>                                <div class="component-name">Pulse</div>                            </div>                        </div>                    </div>                    <!-- Output Controls -->                    <div class="component-section">                        <div class="section-header" onclick="toggleSection('outputs')">                            <div class="section-icon">                                <i class="fas fa-lightbulb"></i>                                <span>Output Controls</span>                            </div>                            <i class="fas fa-chevron-down section-chevron" id="outputs-arrow"></i>                        </div>                        <div class="section-grid" id="outputs-content">                            <div class="component-card component-item" draggable="true" data-type="bulb" title="Light Bulb">                                <div class="component-icon"><i class="fas fa-lightbulb"></i></div>                                <div class="component-name">Bulb</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="digit" title="7-Segment Display">                                <div class="component-icon"><i class="fas fa-hashtag"></i></div>                                <div class="component-name">Display</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="led" title="LED Indicator">                                <div class="component-icon"><i class="fas fa-circle"></i></div>                                <div class="component-name">LED</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="buzzer" title="Buzzer">                                <div class="component-icon"><i class="fas fa-volume-up"></i></div>                                <div class="component-name">Buzzer</div>                            </div>                        </div>                    </div>                    <!-- Basic Logic Gates -->                    <div class="component-section">                        <div class="section-header" onclick="toggleSection('basic-gates')">                            <div class="section-icon">                                <i class="fas fa-microchip"></i>                                <span>Basic Logic Gates</span>                            </div>                            <i class="fas fa-chevron-down section-chevron" id="basic-gates-arrow"></i>                        </div>                        <div class="section-grid" id="basic-gates-content">                            <div class="component-card component-item" draggable="true" data-type="and" title="AND Gate">                                <div class="component-icon"><i class="fas fa-square"></i></div>                                <div class="component-name">AND</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="or" title="OR Gate">                                <div class="component-icon"><i class="fas fa-circle"></i></div>                                <div class="component-name">OR</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="not" title="NOT Gate">                                <div class="component-icon"><i class="fas fa-exclamation"></i></div>                                <div class="component-name">NOT</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="buffer" title="Buffer">                                <div class="component-icon"><i class="fas fa-arrow-right"></i></div>                                <div class="component-name">Buffer</div>                            </div>                        </div>                    </div>                    <!-- Advanced Logic Gates -->                    <div class="component-section">                        <div class="section-header" onclick="toggleSection('advanced-gates')">                            <div class="section-icon">                                <i class="fas fa-brain"></i>                                <span>Advanced Gates</span>                            </div>                            <i class="fas fa-chevron-down section-chevron" id="advanced-gates-arrow"></i>                        </div>                        <div class="section-grid" id="advanced-gates-content">                            <div class="component-card component-item" draggable="true" data-type="nand" title="NAND Gate">                                <div class="component-icon"><i class="fas fa-ban"></i></div>                                <div class="component-name">NAND</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="nor" title="NOR Gate">                                <div class="component-icon"><i class="fas fa-times-circle"></i></div>                                <div class="component-name">NOR</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="xor" title="XOR Gate">                                <div class="component-icon"><i class="fas fa-plus"></i></div>                                <div class="component-name">XOR</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="xnor" title="XNOR Gate">                                <div class="component-icon"><i class="fas fa-equals"></i></div>                                <div class="component-name">XNOR</div>                            </div>                        </div>                    </div>                    <!-- Arithmetic Components -->                    <div class="component-section">                        <div class="section-header" onclick="toggleSection('arithmetic')">                            <div class="section-icon">                                <i class="fas fa-calculator"></i>                                <span>Arithmetic</span>                            </div>                            <i class="fas fa-chevron-down section-chevron" id="arithmetic-arrow"></i>                        </div>                        <div class="section-grid" id="arithmetic-content">                            <div class="component-card component-item" draggable="true" data-type="half-adder" title="Half Adder">                                <div class="component-icon"><i class="fas fa-plus-circle"></i></div>                                <div class="component-name">Half Add</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="full-adder" title="Full Adder">                                <div class="component-icon"><i class="fas fa-plus-square"></i></div>                                <div class="component-name">Full Add</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="ripple-adder" title="4-Bit Ripple Adder">                                <div class="component-icon"><i class="fas fa-layer-group"></i></div>                                <div class="component-name">4-Bit Add</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="subtractor" title="Subtractor">                                <div class="component-icon"><i class="fas fa-minus-circle"></i></div>                                <div class="component-name">Subtract</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="comparator" title="Comparator">                                <div class="component-icon"><i class="fas fa-balance-scale"></i></div>                                <div class="component-name">Compare</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="multiplier" title="Multiplier">                                <div class="component-icon"><i class="fas fa-times"></i></div>                                <div class="component-name">Multiply</div>                            </div>                        </div>                    </div>                    <!-- Memory & Storage -->                    <div class="component-section">                        <div class="section-header" onclick="toggleSection('memory')">                            <div class="section-icon">                                <i class="fas fa-memory"></i>                                <span>Memory & Storage</span>                            </div>                            <i class="fas fa-chevron-down section-chevron" id="memory-arrow"></i>                        </div>                        <div class="section-grid" id="memory-content">                            <div class="component-card component-item" draggable="true" data-type="sr-latch" title="SR Latch">                                <div class="component-icon"><i class="fas fa-grip-horizontal"></i></div>                                <div class="component-name">SR Latch</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="d-latch" title="D Latch">                                <div class="component-icon"><i class="fas fa-square"></i></div>                                <div class="component-name">D Latch</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="jk-flipflop" title="JK Flip-Flop">                                <div class="component-icon"><i class="fas fa-toggle-on"></i></div>                                <div class="component-name">JK FF</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="d-flipflop" title="D Flip-Flop">                                <div class="component-icon"><i class="fas fa-toggle-off"></i></div>                                <div class="component-name">D FF</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="register" title="4-Bit Register">                                <div class="component-icon"><i class="fas fa-database"></i></div>                                <div class="component-name">Register</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="counter" title="Binary Counter">                                <div class="component-icon"><i class="fas fa-sort-numeric-up"></i></div>                                <div class="component-name">Counter</div>                            </div>                        </div>                    </div>                    <!-- Multiplexers & Decoders -->                    <div class="component-section">                        <div class="section-header" onclick="toggleSection('mux-decoder')">                            <div class="section-icon">                                <i class="fas fa-random"></i>                                <span>Mux & Decoders</span>                            </div>                            <i class="fas fa-chevron-down section-chevron" id="mux-decoder-arrow"></i>                        </div>                        <div class="section-grid" id="mux-decoder-content">                            <div class="component-card component-item" draggable="true" data-type="mux-2to1" title="2:1 Multiplexer">                                <div class="component-icon"><i class="fas fa-code-branch"></i></div>                                <div class="component-name">2:1 MUX</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="mux-4to1" title="4:1 Multiplexer">                                <div class="component-icon"><i class="fas fa-project-diagram"></i></div>                                <div class="component-name">4:1 MUX</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="demux-1to2" title="1:2 Demultiplexer">                                <div class="component-icon"><i class="fas fa-share-alt"></i></div>                                <div class="component-name">1:2 DEMUX</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="decoder-2to4" title="2:4 Decoder">                                <div class="component-icon"><i class="fas fa-unlock"></i></div>                                <div class="component-name">2:4 DEC</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="encoder-4to2" title="4:2 Encoder">                                <div class="component-icon"><i class="fas fa-lock"></i></div>                                <div class="component-name">4:2 ENC</div>                            </div>                            <div class="component-card component-item" draggable="true" data-type="priority-encoder" title="Priority Encoder">                                <div class="component-icon"><i class="fas fa-sort-amount-down"></i></div>                                <div class="component-name">Pri ENC</div>                            </div>                        </div>                    </div>                </div>                <!-- Boolean Algebra Tab -->                <div id="boolean-tab" class="tab-content" style="display: none;">                    <div class="boolean-tools">                        <div class="tool-section">                            <div class="tool-title">                                <i class="fas fa-function"></i>                                Boolean Expression Simplifier                            </div>                            <input type="text" class="expression-input" id="boolean-input"                                   placeholder="Enter expression (e.g., A+B'C+AB')" />                            <button class="tool-btn" onclick="simplifyExpression()">Simplify</button>                            <button class="tool-btn" onclick="expandExpression()">Expand</button>                            <button class="tool-btn" onclick="convertToSOP()">To SOP</button>                            <button class="tool-btn" onclick="convertToPOS()">To POS</button>                            <div class="result-area" id="boolean-result"></div>                        </div>                        <div class="tool-section">                            <div class="tool-title">                                <i class="fas fa-code"></i>                                Logic Laws & Theorems                            </div>                            <button class="tool-btn" onclick="showDeMorganLaw()">De Morgan's Law</button>                            <button class="tool-btn" onclick="showDistributiveLaw()">Distributive Law</button>                            <button class="tool-btn" onclick="showAbsorptionLaw()">Absorption Law</button>                            <button class="tool-btn" onclick="showIdentityLaws()">Identity Laws</button>                            <div class="result-area" id="laws-result"></div>                        </div>                        <div class="tool-section">                            <div class="tool-title">                                <i class="fas fa-calculator"></i>                                Expression Evaluator                            </div>                            <input type="text" class="expression-input" id="eval-expression"                                   placeholder="Expression to evaluate" />                            <div style="margin: 12px 0;">                                <label><input type="checkbox" id="var-a"> A = 1</label>                                <label><input type="checkbox" id="var-b"> B = 1</label>                                <label><input type="checkbox" id="var-c"> C = 1</label>                                <label><input type="checkbox" id="var-d"> D = 1</label>                            </div>                            <button class="tool-btn" onclick="evaluateExpression()">Evaluate</button>                            <button class="tool-btn" onclick="generateTruthTable()">Truth Table</button>                            <div class="result-area" id="eval-result"></div>                        </div>                    </div>                </div>                <!-- K-Map Tab -->                <div id="kmap-tab" class="tab-content" style="display: none;">                    <div class="boolean-tools">                        <div class="tool-section">                            <div class="tool-title">                                <i class="fas fa-th"></i>                                Karnaugh Map Solver                            </div>                            <div>                                <label>Variables:</label>                                <select id="kmap-vars" onchange="generateKMap()">                                    <option value="2">2 Variables (A, B)</option>                                    <option value="3">3 Variables (A, B, C)</option>                                    <option value="4">4 Variables (A, B, C, D)</option>                                </select>                            </div>                            <div class="kmap-container" id="kmap-container">                                <!-- K-Map will be generated here -->                            </div>                            <button class="tool-btn" onclick="solveKMap()">Solve</button>                            <button class="tool-btn" onclick="clearKMap()">Clear</button>                            <button class="tool-btn" onclick="fillFromTruthTable()">From Truth Table</button>                            <div class="result-area" id="kmap-result"></div>                        </div>                        <div class="tool-section">                            <div class="tool-title">                                <i class="fas fa-chart-area"></i>                                Prime Implicants                            </div>                            <button class="tool-btn" onclick="findPrimeImplicants()">Find Prime Implicants</button>                            <button class="tool-btn" onclick="findEssentialImplicants()">Essential Implicants</button>                            <div class="result-area" id="implicants-result"></div>                        </div>                    </div>                </div>                <!-- Truth Table Tab -->                <div id="truth-tab" class="tab-content" style="display: none;">                    <div class="boolean-tools">                        <div class="tool-section">                            <div class="tool-title">                                <i class="fas fa-table"></i>                                Truth Table Generator                            </div>                            <input type="text" class="expression-input" id="truth-expression"                                   placeholder="Enter Boolean expression" />                            <button class="tool-btn" onclick="generateFullTruthTable()">Generate Table</button>                            <button class="tool-btn" onclick="exportTruthTable()">Export CSV</button>                            <div class="result-area" id="truth-table-container"></div>                        </div>                        <div class="tool-section">                            <div class="tool-title">                                <i class="fas fa-file-import"></i>                                Import Truth Table                            </div>                            <input type="file" id="truth-file" accept=".csv" onchange="importTruthTable()" />                            <button class="tool-btn" onclick="document.getElementById('truth-file').click()">Import CSV</button>                        </div>                    </div>                </div>            </div>        </aside>        <!-- Main Workspace -->        <main class="main-workspace">            <div class="workspace-toolbar">                <div class="toolbar-group">                    <button class="toolbar-btn" onclick="clearCanvas()" title="Clear All">                        <i class="fas fa-trash-alt"></i>                        <span>Clear</span>                    </button>                    <button class="toolbar-btn" onclick="saveCircuit()" title="Save Circuit">                        <i class="fas fa-save"></i>                        <span>Save</span>                    </button>                    <button class="toolbar-btn" onclick="loadCircuit()" title="Load Circuit">                        <i class="fas fa-folder-open"></i>                        <span>Load</span>                    </button>                </div>                                <div class="toolbar-group">                    <button class="toolbar-btn" onclick="undo()" title="Undo">                        <i class="fas fa-undo"></i>                        <span>Undo</span>                    </button>                    <button class="toolbar-btn" onclick="redo()" title="Redo">                        <i class="fas fa-redo"></i>                        <span>Redo</span>                    </button>                </div>                                <div class="toolbar-group">                    <button class="toolbar-btn primary" id="wire-mode" onclick="toggleWireMode()" title="Wire Mode">                        <i class="fas fa-project-diagram"></i>                        <span>Wire Mode</span>                    </button>                    <button class="toolbar-btn" id="select-mode" onclick="toggleSelectMode()" title="Select Mode">                        <i class="fas fa-mouse-pointer"></i>                        <span>Select</span>                    </button>                </div>                <div class="toolbar-group">                    <button class="toolbar-btn" onclick="zoomIn()" title="Zoom In">                        <i class="fas fa-search-plus"></i>                    </button>                    <button class="toolbar-btn" onclick="zoomOut()" title="Zoom Out">                        <i class="fas fa-search-minus"></i>                    </button>                    <button class="toolbar-btn" onclick="resetZoom()" title="Reset Zoom">                        <i class="fas fa-expand-arrows-alt"></i>                    </button>                </div>                <div class="toolbar-group">                    <button class="toolbar-btn" onclick="runSimulation()" title="Run Simulation">                        <i class="fas fa-play"></i>                        <span>Simulate</span>                    </button>                    <button class="toolbar-btn" onclick="stepSimulation()" title="Step">                        <i class="fas fa-step-forward"></i>                        <span>Step</span>                    </button>                    <button class="toolbar-btn" onclick="resetSimulation()" title="Reset">                        <i class="fas fa-stop"></i>                        <span>Reset</span>                    </button>                </div>            </div>            <div class="canvas-workspace" id="canvas-container">                <canvas class="grid-canvas" id="grid-canvas"></canvas>                <canvas class="canvas" id="canvas"></canvas>                <svg class="wire-preview" id="wire-preview" style="display: none;">                    <path id="preview-path" fill="none"/>                </svg>            </div>        </main>        <!-- Properties Panel -->        <div class="properties-panel" id="properties-panel">            <div class="properties-header">                <div class="properties-title">Properties</div>                <div class="properties-subtitle">Component settings and information</div>            </div>            <div class="properties-content" id="properties-content">                <div class="property-group">                    <p style="color: var(--text-tertiary); font-size: 14px;">Select a component to view its properties</p>                </div>            </div>        </div>    </div> <script>        // Global variables        let components = [];        let wires = [];        let selectedComponent = null;        let isDragging = false;        let dragOffset = { x: 0, y: 0 };        let isWireMode = false;        let wireStart = null;        let scale = 1;        let panX = 0;        let panY = 0;        let gridSize = 20;        let componentIdCounter = 0;        let wireIdCounter = 0;        let undoStack = [];        let redoStack = [];        let maxUndoSteps = 50;        let currentTab = 'components';        let currentMode = 'design';        let simulationRunning = false;        let simulationSpeed = 100; // ms        // Canvas setup        const canvas = document.getElementById('canvas');        const ctx = canvas.getContext('2d');        const gridCanvas = document.getElementById('grid-canvas');        const gridCtx = gridCanvas.getContext('2d');        const canvasContainer = document.getElementById('canvas-container');        const wirePreview = document.getElementById('wire-preview');        const previewPath = document.getElementById('preview-path');        // Enhanced component types with new components        const componentTypes = {            // Input components            toggle: {                width: 40, height: 30, inputs: 0, outputs: 1,                render: (comp) => drawToggle(comp),                evaluate: (comp) => comp.state || false            },            button: {                width: 40, height: 30, inputs: 0, outputs: 1,                render: (comp) => drawButton(comp),                evaluate: (comp) => comp.pressed || false            },            clock: {                width: 40, height: 30, inputs: 0, outputs: 1,                render: (comp) => drawClock(comp),                evaluate: (comp) => comp.clockState || false            },            high: {                width: 30, height: 20, inputs: 0, outputs: 1,                render: (comp) => drawConstant(comp, '1'),                evaluate: (comp) => true            },            low: {                width: 30, height: 20, inputs: 0, outputs: 1,                render: (comp) => drawConstant(comp, '0'),                evaluate: (comp) => false            },            pulse: {                width: 40, height: 30, inputs: 0, outputs: 1,                render: (comp) => drawPulse(comp),                evaluate: (comp) => comp.pulseState || false            },            // Output components            bulb: {                width: 30, height: 30, inputs: 1, outputs: 0,                render: (comp) => drawBulb(comp),                evaluate: (comp) => null            },            digit: {                width: 40, height: 50, inputs: 4, outputs: 0,                render: (comp) => drawDigit(comp),                evaluate: (comp) => null            },            led: {                width: 20, height: 20, inputs: 1, outputs: 0,                render: (comp) => drawLED(comp),                evaluate: (comp) => null            },            buzzer: {                width: 30, height: 30, inputs: 1, outputs: 0,                render: (comp) => drawBuzzer(comp),                evaluate: (comp) => null            },            // Basic logic gates            and: {                width: 60, height: 40, inputs: 2, outputs: 1,                render: (comp) => drawGate(comp, 'AND'),                evaluate: (comp) => comp.inputs.every(val => val)            },            or: {                width: 60, height: 40, inputs: 2, outputs: 1,                render: (comp) => drawGate(comp, 'OR'),                evaluate: (comp) => comp.inputs.some(val => val)            },            not: {                width: 50, height: 30, inputs: 1, outputs: 1,                render: (comp) => drawGate(comp, 'NOT'),                evaluate: (comp) => !comp.inputs[0]            },            buffer: {                width: 50, height: 30, inputs: 1, outputs: 1,                render: (comp) => drawGate(comp, 'BUF'),                evaluate: (comp) => comp.inputs[0]            },            // Advanced logic gates            nand: {                width: 60, height: 40, inputs: 2, outputs: 1,                render: (comp) => drawGate(comp, 'NAND'),                evaluate: (comp) => !comp.inputs.every(val => val)            },            nor: {                width: 60, height: 40, inputs: 2, outputs: 1,                render: (comp) => drawGate(comp, 'NOR'),                evaluate: (comp) => !comp.inputs.some(val => val)            },            xor: {                width: 60, height: 40, inputs: 2, outputs: 1,                render: (comp) => drawGate(comp, 'XOR'),                evaluate: (comp) => comp.inputs.filter(val => val).length === 1            },            xnor: {                width: 60, height: 40, inputs: 2, outputs: 1,                render: (comp) => drawGate(comp, 'XNOR'),                evaluate: (comp) => comp.inputs.filter(val => val).length !== 1            },            // Arithmetic components            'half-adder': {                width: 80, height: 50, inputs: 2, outputs: 2,                render: (comp) => drawArithmetic(comp, 'HA'),                evaluate: (comp) => {                    const a = comp.inputs[0];                    const b = comp.inputs[1];                    return [a ^ b, a & b]; // Sum, Carry                }            },            'full-adder': {                width: 80, height: 60, inputs: 3, outputs: 2,                render: (comp) => drawArithmetic(comp, 'FA'),                evaluate: (comp) => {                    const a = comp.inputs[0];                    const b = comp.inputs[1];                    const cin = comp.inputs[2];                    const sum = a ^ b ^ cin;                    const cout = (a & b) | (cin & (a ^ b));                    return [sum, cout]; // Sum, Carry Out                }            },            'ripple-adder': {                width: 100, height: 80, inputs: 9, outputs: 5,                render: (comp) => drawArithmetic(comp, '4-BIT'),                evaluate: (comp) => {                    // 4-bit ripple carry adder                    let carry = comp.inputs[8]; // Carry in                    const results = [];                                        for (let i = 0; i < 4; i++) {                        const a = comp.inputs[i];                        const b = comp.inputs[i + 4];                        const sum = a ^ b ^ carry;                        carry = (a & b) | (carry & (a ^ b));                        results.push(sum);                    }                    results.push(carry); // Final carry out                    return results;                }            },            subtractor: {                width: 80, height: 60, inputs: 3, outputs: 2,                render: (comp) => drawArithmetic(comp, 'SUB'),                evaluate: (comp) => {                    const a = comp.inputs[0];                    const b = comp.inputs[1];                    const bin = comp.inputs[2];                    const diff = a ^ b ^ bin;                    const bout = (!a & b) | (bin & !(a ^ b));                    return [diff, bout]; // Difference, Borrow                }            },            comparator: {                width: 80, height: 60, inputs: 4, outputs: 3,                render: (comp) => drawArithmetic(comp, 'CMP'),                evaluate: (comp) => {                    const a = (comp.inputs[1] << 1) | comp.inputs[0];                    const b = (comp.inputs[3] << 1) | comp.inputs[2];                    return [a > b, a === b, a < b]; // Greater, Equal, Less                }            },            multiplier: {                width: 80, height: 60, inputs: 4, outputs: 4,                render: (comp) => drawArithmetic(comp, 'MUL'),                evaluate: (comp) => {                    const a = (comp.inputs[1] << 1) | comp.inputs[0];                    const b = (comp.inputs[3] << 1) | comp.inputs[2];                    const result = a * b;                    return [                        (result & 1) !== 0,                        (result & 2) !== 0,                        (result & 4) !== 0,                        (result & 8) !== 0                    ];                }            },            // Memory & Storage            'sr-latch': {                width: 70, height: 50, inputs: 2, outputs: 2,                render: (comp) => drawMemory(comp, 'SR'),                evaluate: (comp) => {                    const s = comp.inputs[0];                    const r = comp.inputs[1];                    if (s && r) return [false, false]; // Invalid state                    if (s) return [true, false];                    if (r) return [false, true];                    return comp.lastOutputs || [false, true];                }            },            'd-latch': {                width: 70, height: 50, inputs: 2, outputs: 2,                render: (comp) => drawMemory(comp, 'D'),                evaluate: (comp) => {                    const d = comp.inputs[0];                    const enable = comp.inputs[1];                    if (enable) {                        return [d, !d];                    }                    return comp.lastOutputs || [false, true];                }            },            'jk-flipflop': {                width: 70, height: 60, inputs: 3, outputs: 2,                render: (comp) => drawMemory(comp, 'JK'),                evaluate: (comp) => {                    const j = comp.inputs[0];                    const k = comp.inputs[1];                    const clk = comp.inputs[2];                                        if (clk && !comp.lastClock) { // Rising edge                        const q = comp.lastOutputs ? comp.lastOutputs[0] : false;                        if (j && k) return [!q, q]; // Toggle                        if (j) return [true, false];                        if (k) return [false, true];                    }                    comp.lastClock = clk;                    return comp.lastOutputs || [false, true];                }            },            'd-flipflop': {                width: 70, height: 50, inputs: 2, outputs: 2,                render: (comp) => drawMemory(comp, 'DFF'),                evaluate: (comp) => {                    const d = comp.inputs[0];                    const clk = comp.inputs[1];                                        if (clk && !comp.lastClock) { // Rising edge                        comp.lastClock = clk;                        return [d, !d];                    }                    comp.lastClock = clk;                    return comp.lastOutputs || [false, true];                }            },            register: {                width: 90, height: 70, inputs: 6, outputs: 4,                render: (comp) => drawMemory(comp, 'REG'),                evaluate: (comp) => {                    const clk = comp.inputs[4];                    const enable = comp.inputs[5];                                        if (clk && !comp.lastClock && enable) { // Rising edge with enable                        comp.lastClock = clk;                        return [comp.inputs[0], comp.inputs[1], comp.inputs[2], comp.inputs[3]];                    }                    comp.lastClock = clk;                    return comp.lastOutputs || [false, false, false, false];                }            },            counter: {                width: 70, height: 60, inputs: 2, outputs: 4,                render: (comp) => drawMemory(comp, 'CNT'),                evaluate: (comp) => {                    const clk = comp.inputs[0];                    const reset = comp.inputs[1];                                        if (reset) {                        comp.count = 0;                        return [false, false, false, false];                    }                                        if (clk && !comp.lastClock) { // Rising edge                        comp.count = (comp.count || 0) + 1;                        if (comp.count > 15) comp.count = 0;                    }                    comp.lastClock = clk;                                        const count = comp.count || 0;                    return [                        (count & 1) !== 0,                        (count & 2) !== 0,                        (count & 4) !== 0,                        (count & 8) !== 0                    ];                }            },            // Multiplexers & Decoders            'mux-2to1': {                width: 70, height: 50, inputs: 3, outputs: 1,                render: (comp) => drawMuxDecoder(comp, '2:1M'),                evaluate: (comp) => {                    const sel = comp.inputs[2];                    return sel ? comp.inputs[1] : comp.inputs[0];                }            },            'mux-4to1': {                width: 80, height: 70, inputs: 6, outputs: 1,                render: (comp) => drawMuxDecoder(comp, '4:1M'),                evaluate: (comp) => {                    const sel = (comp.inputs[5] << 1) | comp.inputs[4];                    return comp.inputs[sel] || false;                }            },            'demux-1to2': {                width: 70, height: 50, inputs: 2, outputs: 2,                render: (comp) => drawMuxDecoder(comp, '1:2D'),                evaluate: (comp) => {                    const sel = comp.inputs[1];                    const input = comp.inputs[0];                    return sel ? [false, input] : [input, false];                }            },            'decoder-2to4': {                width: 80, height: 70, inputs: 2, outputs: 4,                render: (comp) => drawMuxDecoder(comp, '2:4D'),                evaluate: (comp) => {                    const sel = (comp.inputs[1] << 1) | comp.inputs[0];                    const outputs = [false, false, false, false];                    outputs[sel] = true;                    return outputs;                }            },            'encoder-4to2': {                width: 80, height: 70, inputs: 4, outputs: 2,                render: (comp) => drawMuxDecoder(comp, '4:2E'),                evaluate: (comp) => {                    for (let i = 3; i >= 0; i--) {                        if (comp.inputs[i]) {                            return [(i & 1) !== 0, (i & 2) !== 0];                        }                    }                    return [false, false];                }            },            'priority-encoder': {                width: 80, height: 70, inputs: 4, outputs: 3,                render: (comp) => drawMuxDecoder(comp, 'PE'),                evaluate: (comp) => {                    let validOutput = false;                    for (let i = 3; i >= 0; i--) {                        if (comp.inputs[i]) {                            return [(i & 1) !== 0, (i & 2) !== 0, true];                        }                    }                    return [false, false, false]; // No valid input                }            }        };        // Initialize canvas        function initCanvas() {            resizeCanvas();            drawGrid();            window.addEventListener('resize', () => {                resizeCanvas();                drawGrid();                redraw();            });        }        function resizeCanvas() {            const rect = canvasContainer.getBoundingClientRect();            canvas.width = rect.width;            canvas.height = rect.height;            gridCanvas.width = rect.width;            gridCanvas.height = rect.height;                        wirePreview.setAttribute('width', rect.width);            wirePreview.setAttribute('height', rect.height);        }        function drawGrid() {            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);            gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';            gridCtx.lineWidth = 0.5;            const startX = (-panX % (gridSize * scale));            const startY = (-panY % (gridSize * scale));                        for (let x = startX; x < gridCanvas.width; x += gridSize * scale) {                gridCtx.beginPath();                gridCtx.moveTo(x, 0);                gridCtx.lineTo(x, gridCanvas.height);                gridCtx.stroke();            }                        for (let y = startY; y < gridCanvas.height; y += gridSize * scale) {                gridCtx.beginPath();                gridCtx.moveTo(0, y);                gridCtx.lineTo(gridCanvas.width, y);                gridCtx.stroke();            }        }        function snapToGrid(x, y) {            const gridX = Math.round((x - panX) / (gridSize * scale)) * gridSize;            const gridY = Math.round((y - panY) / (gridSize * scale)) * gridSize;            return { x: gridX, y: gridY };        }        // Enhanced drawing functions        function drawToggle(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Background            ctx.fillStyle = comp.state ? '#10b981' : '#6b7280';            ctx.fillRect(x, y, w, h);                        // Switch handle            const handleW = w * 0.4;            const handleH = h * 0.8;            const handleX = comp.state ? x + w - handleW - 4 : x + 4;            const handleY = y + (h - handleH) / 2;                        ctx.fillStyle = '#ffffff';            ctx.fillRect(handleX, handleY, handleW, handleH);                        // Border            ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.strokeRect(x, y, w, h);                        // Label            ctx.fillStyle = '#ffffff';            ctx.font = `bold ${10 * scale}px Inter`;            ctx.textAlign = 'center';            ctx.fillText(comp.state ? 'ON' : 'OFF', x + w/2, y + h + 15 * scale);        }        function drawButton(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Button body            const pressed = comp.pressed;            ctx.fillStyle = pressed ? '#3b82f6' : '#6b7280';            ctx.fillRect(x + (pressed ? 2 : 0), y + (pressed ? 2 : 0), w - (pressed ? 2 : 0), h - (pressed ? 2 : 0));                        // Shadow effect            if (!pressed) {                ctx.fillStyle = 'rgba(0,0,0,0.3)';                ctx.fillRect(x + 2, y + 2, w, h);            }                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.strokeRect(x + (pressed ? 2 : 0), y + (pressed ? 2 : 0), w - (pressed ? 2 : 0), h - (pressed ? 2 : 0));                        // Label            ctx.fillStyle = '#ffffff';            ctx.font = `bold ${9 * scale}px Inter`;            ctx.textAlign = 'center';            ctx.fillText('BTN', x + w/2, y + h/2 + 3 * scale);        }        function drawClock(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Clock body            ctx.fillStyle = comp.clockState ? '#f59e0b' : '#6b7280';            ctx.fillRect(x, y, w, h);                        // Clock wave pattern            ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.beginPath();            const segments = 6;            for (let i = 0; i <= segments; i++) {                const segX = x + (w / segments) * i;                const segY = y + h/2 + (i % 2 ? -h/4 : h/4);                if (i === 0) ctx.moveTo(segX, segY);                else ctx.lineTo(segX, segY);            }            ctx.stroke();                        ctx.strokeRect(x, y, w, h);        }        function drawPulse(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            ctx.fillStyle = comp.pulseState ? '#ec4899' : '#6b7280';            ctx.fillRect(x, y, w, h);                        // Pulse icon            ctx.fillStyle = '#ffffff';            ctx.font = `${16 * scale}px Font Awesome`;            ctx.textAlign = 'center';            ctx.fillText('?', x + w/2, y + h/2 + 5 * scale);                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.strokeRect(x, y, w, h);        }        function drawConstant(comp, value) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            ctx.fillStyle = value === '1' ? '#10b981' : '#6b7280';            ctx.fillRect(x, y, w, h);            ctx.strokeStyle = '#ffffff';            ctx.strokeRect(x, y, w, h);                        ctx.fillStyle = '#ffffff';            ctx.font = `bold ${16 * scale}px Inter`;            ctx.textAlign = 'center';            ctx.fillText(value, x + w/2, y + h/2 + 5 * scale);        }        function drawLED(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            const isOn = comp.inputValues && comp.inputValues[0];                        ctx.fillStyle = isOn ? '#ef4444' : '#374151';            ctx.beginPath();            ctx.arc(x + w/2, y + h/2, w/2, 0, 2 * Math.PI);            ctx.fill();                        if (isOn) {                ctx.shadowColor = '#ef4444';                ctx.shadowBlur = 15 * scale;                ctx.fill();                ctx.shadowBlur = 0;            }                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.stroke();        }        function drawBulb(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            const isOn = comp.inputValues && comp.inputValues[0];                        ctx.fillStyle = isOn ? '#fbbf24' : '#374151';            ctx.beginPath();            ctx.arc(x + w/2, y + h/2, w/2 - 2, 0, 2 * Math.PI);            ctx.fill();                        if (isOn) {                ctx.shadowColor = '#fbbf24';                ctx.shadowBlur = 20 * scale;                ctx.fill();                ctx.shadowBlur = 0;            }                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.stroke();        }        function drawBuzzer(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            const isOn = comp.inputValues && comp.inputValues[0];                        ctx.fillStyle = isOn ? '#8b5cf6' : '#374151';            ctx.fillRect(x, y, w, h);                        // Sound waves            if (isOn) {                ctx.strokeStyle = '#ffffff';                ctx.lineWidth = 2;                for (let i = 1; i <= 3; i++) {                    ctx.beginPath();                    ctx.arc(x + w/2, y + h/2, i * 8 * scale, 0, Math.PI * 2);                    ctx.stroke();                }            }                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.strokeRect(x, y, w, h);                        // Speaker icon            ctx.fillStyle = '#ffffff';            ctx.font = `${12 * scale}px Font Awesome`;            ctx.textAlign = 'center';            ctx.fillText('?', x + w/2, y + h/2 + 4 * scale);        }        function drawDigit(comp) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            ctx.fillStyle = '#000000';            ctx.fillRect(x, y, w, h);            ctx.strokeStyle = '#ffffff';            ctx.strokeRect(x, y, w, h);            // Calculate digit value from 4-bit input            let value = 0;            if (comp.inputValues) {                for (let i = 0; i < 4; i++) {                    if (comp.inputValues[i]) {                        value += Math.pow(2, i);                    }                }            }                        ctx.fillStyle = '#ff0000';            ctx.font = `bold ${24 * scale}px JetBrains Mono`;            ctx.textAlign = 'center';            ctx.fillText(value.toString(16).toUpperCase(), x + w/2, y + h/2 + 8 * scale);        }        function drawGate(comp, label) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Gate body with gradient            const gradient = ctx.createLinearGradient(x, y, x, y + h);            gradient.addColorStop(0, '#4b5563');            gradient.addColorStop(1, '#374151');            ctx.fillStyle = gradient;                        // Special shapes for different gates            if (label === 'AND' || label === 'NAND') {                ctx.beginPath();                ctx.moveTo(x, y);                ctx.lineTo(x + w * 0.6, y);                ctx.arc(x + w * 0.6, y + h/2, h/2, -Math.PI/2, Math.PI/2);                ctx.lineTo(x, y + h);                ctx.closePath();                ctx.fill();                ctx.stroke();            } else if (label === 'OR' || label === 'NOR') {                ctx.beginPath();                ctx.moveTo(x, y);                ctx.quadraticCurveTo(x + w * 0.7, y, x + w * 0.8, y + h/2);                ctx.quadraticCurveTo(x + w * 0.7, y + h, x, y + h);                ctx.quadraticCurveTo(x + w * 0.3, y + h/2, x, y);                ctx.fill();                ctx.stroke();            } else {                // Default rectangular shape                ctx.fillRect(x, y, w, h);                ctx.strokeRect(x, y, w, h);            }                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;                        // Label            ctx.fillStyle = '#ffffff';            ctx.font = `bold ${11 * scale}px Inter`;            ctx.textAlign = 'center';            ctx.fillText(label, x + w/2, y + h/2 + 4 * scale);            // Inversion bubble for inverted gates            if (label.includes('N') || label === 'NOT') {                ctx.beginPath();                ctx.arc(x + w + 4 * scale, y + h/2, 4 * scale, 0, 2 * Math.PI);                ctx.fillStyle = '#ffffff';                ctx.fill();                ctx.strokeStyle = '#ffffff';                ctx.stroke();            }        }        function drawArithmetic(comp, label) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Arithmetic unit body            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);            gradient.addColorStop(0, '#3b82f6');            gradient.addColorStop(1, '#1e40af');            ctx.fillStyle = gradient;            ctx.fillRect(x, y, w, h);                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.strokeRect(x, y, w, h);                        // Label            ctx.fillStyle = '#ffffff';            ctx.font = `bold ${10 * scale}px Inter`;            ctx.textAlign = 'center';            ctx.fillText(label, x + w/2, y + h/2 + 3 * scale);        }        function drawMemory(comp, label) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Memory unit body            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);            gradient.addColorStop(0, '#8b5cf6');            gradient.addColorStop(1, '#7c3aed');            ctx.fillStyle = gradient;            ctx.fillRect(x, y, w, h);                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.strokeRect(x, y, w, h);                        // Clock triangle for clocked components            if (label.includes('FF') || label === 'REG' || label === 'CNT') {                ctx.beginPath();                ctx.moveTo(x - 1, y + h * 0.7);                ctx.lineTo(x + 8 * scale, y + h * 0.7 - 4 * scale);                ctx.lineTo(x + 8 * scale, y + h * 0.7 + 4 * scale);                ctx.closePath();                ctx.fillStyle = '#ffffff';                ctx.fill();            }                        // Label            ctx.fillStyle = '#ffffff';            ctx.font = `bold ${10 * scale}px Inter`;            ctx.textAlign = 'center';            ctx.fillText(label, x + w/2, y + h/2 + 3 * scale);        }        function drawMuxDecoder(comp, label) {            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Mux/Decoder body            const gradient = ctx.createLinearGradient(x, y, x + w, y + h);            gradient.addColorStop(0, '#10b981');            gradient.addColorStop(1, '#059669');            ctx.fillStyle = gradient;                        // Trapezoidal shape for mux/demux            if (label.includes('M') || label.includes('D')) {                ctx.beginPath();                if (label.includes('M')) { // Multiplexer                    ctx.moveTo(x, y);                    ctx.lineTo(x + w * 0.8, y + h * 0.2);                    ctx.lineTo(x + w * 0.8, y + h * 0.8);                    ctx.lineTo(x, y + h);                    ctx.closePath();                } else { // Demultiplexer                    ctx.moveTo(x + w * 0.2, y + h * 0.2);                    ctx.lineTo(x + w, y);                    ctx.lineTo(x + w, y + h);                    ctx.lineTo(x + w * 0.2, y + h * 0.8);                    ctx.closePath();                }                ctx.fill();            } else {                ctx.fillRect(x, y, w, h);            }                        ctx.strokeStyle = '#ffffff';            ctx.lineWidth = 2;            ctx.stroke();                        // Label            ctx.fillStyle = '#ffffff';            ctx.font = `bold ${9 * scale}px Inter`;            ctx.textAlign = 'center';            ctx.fillText(label, x + w/2, y + h/2 + 3 * scale);        }        function drawConnectionPoints(comp) {            const type = componentTypes[comp.type];            const x = comp.x * scale + panX;            const y = comp.y * scale + panY;            const w = comp.width * scale;            const h = comp.height * scale;            // Input points (left side)            for (let i = 0; i < type.inputs; i++) {                const py = y + (h / (type.inputs + 1)) * (i + 1);                const isConnected = wires.some(wire =>                     wire.to.componentId === comp.id && wire.to.port === i                );                const signalValue = comp.inputValues && comp.inputValues[i];                                ctx.fillStyle = signalValue ? '#10b981' : (isConnected ? '#f59e0b' : '#6b7280');                ctx.beginPath();                ctx.arc(x, py, 6 * scale, 0, 2 * Math.PI);                ctx.fill();                ctx.strokeStyle = '#ffffff';                ctx.lineWidth = 2;                ctx.stroke();            }            // Output points (right side)            const outputs = type.evaluate(comp);            for (let i = 0; i < type.outputs; i++) {                const py = y + (h / (type.outputs + 1)) * (i + 1);                const outputValue = Array.isArray(outputs) ? outputs[i] : outputs;                const isConnected = wires.some(wire =>                     wire.from.componentId === comp.id && wire.from.port === i                );                                ctx.fillStyle = outputValue ? '#10b981' : (isConnected ? '#f59e0b' : '#6b7280');                ctx.beginPath();                ctx.arc(x + w, py, 6 * scale, 0, 2 * Math.PI);                ctx.fill();                ctx.strokeStyle = '#ffffff';                ctx.lineWidth = 2;                ctx.stroke();            }        }        function drawWires() {            wires.forEach(wire => {                const fromComp = components.find(c => c.id === wire.from.componentId);                const toComp = components.find(c => c.id === wire.to.componentId);                                if (!fromComp || !toComp) return;                const fromType = componentTypes[fromComp.type];                const toType = componentTypes[toComp.type];                // Calculate connection points                const fromX = (fromComp.x + fromComp.width) * scale + panX;                const fromY = (fromComp.y + (fromComp.height / (fromType.outputs + 1)) * (wire.from.port + 1)) * scale + panY;                                const toX = toComp.x * scale + panX;                const toY = (toComp.y + (toComp.height / (toType.inputs + 1)) * (wire.to.port + 1)) * scale + panY;                // Get signal value                const outputs = fromType.evaluate(fromComp);                const signalValue = Array.isArray(outputs) ? outputs[wire.from.port] : outputs;                                ctx.strokeStyle = signalValue ? '#10b981' : '#6b7280';                ctx.lineWidth = 4 * scale;                ctx.lineCap = 'round';                ctx.lineJoin = 'round';                                // Draw wire with smooth curves                ctx.beginPath();                ctx.moveTo(fromX, fromY);                                const midX = fromX + (toX - fromX) * 0.6;                ctx.bezierCurveTo(midX, fromY, midX, toY, toX, toY);                ctx.stroke();                                // Add glow effect for active signals                if (signalValue) {                    ctx.shadowColor = '#10b981';                    ctx.shadowBlur = 8 * scale;                    ctx.stroke();                    ctx.shadowBlur = 0;                }            });        }        function redraw() {            ctx.clearRect(0, 0, canvas.width, canvas.height);                        // Draw wires first            drawWires();                        // Draw components            components.forEach(comp => {                // Store outputs for memory components                const type = componentTypes[comp.type];                const outputs = type.evaluate(comp);                if (outputs !== null) {                    comp.lastOutputs = Array.isArray(outputs) ? [...outputs] : [outputs];                }                                type.render(comp);                drawConnectionPoints(comp);                                if (comp.selected) {                    const x = comp.x * scale + panX;                    const y = comp.y * scale + panY;                    const w = comp.width * scale;                    const h = comp.height * scale;                                        ctx.strokeStyle = '#3b82f6';                    ctx.lineWidth = 3;                    ctx.strokeRect(x - 4, y - 4, w + 8, h + 8);                                        // Selection glow                    ctx.shadowColor = '#3b82f6';                    ctx.shadowBlur = 10 * scale;                    ctx.strokeRect(x - 4, y - 4, w + 8, h + 8);                    ctx.shadowBlur = 0;                }            });                        // Update counters            document.getElementById('component-count').textContent = components.length;            document.getElementById('wire-count').textContent = wires.length;        }        // Component creation and management        function createComponent(type, x, y) {            const componentType = componentTypes[type];            if (!componentType) {                showToast('Unknown component type: ' + type, 'error');                return null;            }            const component = {                id: componentIdCounter++,                type: type,                x: x,                y: y,                width: componentType.width,                height: componentType.height,                inputs: new Array(componentType.inputs).fill(false),                inputValues: new Array(componentType.inputs).fill(false),                outputs: new Array(componentType.outputs).fill(false),                lastOutputs: new Array(componentType.outputs).fill(false),                selected: false,                state: false,                pressed: false,                clockState: false,                pulseState: false,                clockInterval: null,                pulseInterval: null,                lastClock: false,                count: 0            };            // Initialize clock components            if (type === 'clock') {                component.clockInterval = setInterval(() => {                    component.clockState = !component.clockState;                    simulate();                    redraw();                }, 1000);            }            // Initialize pulse generator            if (type === 'pulse') {                component.pulseInterval = setInterval(() => {                    component.pulseState = !component.pulseState;                    simulate();                    redraw();                }, 500); // Faster pulse            }            components.push(component);            saveState();            simulate();            redraw();            return component;        }        function deleteComponent(comp) {            // Remove connected wires            wires = wires.filter(wire =>                 wire.from.componentId !== comp.id && wire.to.componentId !== comp.id            );                        // Clear intervals            if (comp.clockInterval) clearInterval(comp.clockInterval);            if (comp.pulseInterval) clearInterval(comp.pulseInterval);                        // Remove component            const index = components.indexOf(comp);            if (index > -1) {                components.splice(index, 1);            }                        saveState();            simulate();            redraw();        }        function simulate() {            // Reset all input values            components.forEach(comp => {                comp.inputValues.fill(false);            });            // Multiple passes for complex circuits            for (let pass = 0; pass < 5; pass++) {                // Propagate signals through wires                wires.forEach(wire => {                    const fromComp = components.find(c => c.id === wire.from.componentId);                    const toComp = components.find(c => c.id === wire.to.componentId);                                        if (fromComp && toComp) {                        const fromType = componentTypes[fromComp.type];                        const outputs = fromType.evaluate(fromComp);                        const signalValue = Array.isArray(outputs) ? outputs[wire.from.port] : outputs;                        toComp.inputValues[wire.to.port] = signalValue || false;                    }                });                // Update component states                components.forEach(comp => {                    comp.inputs = [...comp.inputValues];                });            }        }        // UI Functions        function switchTab(tabName) {            currentTab = tabName;                        // Update tab buttons            document.querySelectorAll('.sidebar-tab').forEach(tab => {                tab.classList.remove('active');            });            event.target.classList.add('active');                        // Show/hide tab content            document.querySelectorAll('.tab-content').forEach(content => {                content.style.display = 'none';            });            document.getElementById(tabName + '-tab').style.display = 'block';        }        function toggleSection(sectionId) {            const content = document.getElementById(`${sectionId}-content`);            const header = document.querySelector(`#${sectionId}-arrow`).closest('.section-header');                        if (content.classList.contains('collapsed')) {                content.classList.remove('collapsed');                header.classList.remove('collapsed');            } else {                content.classList.add('collapsed');                header.classList.add('collapsed');            }        }        function toggleSidebar() {            const sidebar = document.getElementById('sidebar');            sidebar.classList.toggle('open');        }        function toggleProperties() {            const panel = document.getElementById('properties-panel');            panel.classList.toggle('open');        }        function updateProperties(comp) {            const content = document.getElementById('properties-content');            if (!comp) {                content.innerHTML = '<div class="property-group"><p style="color: var(--text-tertiary);">Select a component to view properties</p></div>';                return;            }            const type = componentTypes[comp.type];            let html = `                <div class="property-group">                    <label class="property-label">Component ID</label>                    <input type="text" class="property-input" value="${comp.id}" readonly>                </div>                <div class="property-group">                    <label class="property-label">Type</label>                    <input type="text" class="property-input" value="${comp.type}" readonly>                </div>                <div class="property-group">                    <label class="property-label">Position X</label>                    <input type="number" class="property-input" value="${comp.x}" onchange="updateComponentProperty('${comp.id}', 'x', this.value)">                </div>                <div class="property-group">                    <label class="property-label">Position Y</label>                    <input type="number" class="property-input" value="${comp.y}" onchange="updateComponentProperty('${comp.id}', 'y', this.value)">                </div>                <div class="property-group">                    <label class="property-label">Inputs</label>                    <input type="text" class="property-input" value="${type.inputs}" readonly>                </div>                <div class="property-group">                    <label class="property-label">Outputs</label>                    <input type="text" class="property-input" value="${type.outputs}" readonly>                </div>            `;            if (comp.type === 'toggle') {                html += `                    <div class="property-group">                        <label class="property-label">State</label>                        <input type="checkbox" ${comp.state ? 'checked' : ''} onchange="updateComponentProperty('${comp.id}', 'state', this.checked)">                    </div>                `;            }            content.innerHTML = html;        }        function updateComponentProperty(compId, property, value) {            const comp = components.find(c => c.id == compId);            if (comp) {                if (property === 'x' || property === 'y') {                    comp[property] = parseInt(value);                } else if (property === 'state') {                    comp[property] = value;                }                simulate();                redraw();            }        }        function showToast(message, type = 'info') {            const toast = document.createElement('div');            toast.className = `toast ${type}`;            toast.textContent = message;            document.body.appendChild(toast);                        setTimeout(() => toast.classList.add('show'), 100);            setTimeout(() => {                toast.classList.remove('show');                setTimeout(() => document.body.removeChild(toast), 300);            }, 3000);        }        // Boolean Algebra Functions        function simplifyExpression() {            const expr = document.getElementById('boolean-input').value;            const result = document.getElementById('boolean-result');                        if (!expr.trim()) {                result.textContent = 'Please enter a Boolean expression.';                return;            }                        try {                // Simple simplification rules                let simplified = expr                    .replace(/A\+A/g, 'A')          // A+A = A                    .replace(/A\.A/g, 'A')          // A.A = A                    .replace(/A\+A'/g, '1')         // A+A' = 1                    .replace(/A\.A'/g, '0')         // A.A' = 0                    .replace(/A\+0/g, 'A')          // A+0 = A                    .replace(/A\.1/g, 'A')          // A.1 = A                    .replace(/A\+1/g, '1')          // A+1 = 1                    .replace(/A\.0/g, '0')          // A.0 = 0                    .replace(/\(A\+B\)\.A/g, 'A')   // (A+B).A = A                    .replace(/\(A\.B\)\+A/g, 'A');  // (A.B)+A = A                                result.textContent = `Original: ${expr}\nSimplified: ${simplified}`;            } catch (error) {                result.textContent = 'Error: Invalid expression format.';            }        }        function expandExpression() {            const expr = document.getElementById('boolean-input').value;            const result = document.getElementById('boolean-result');                        if (!expr.trim()) {                result.textContent = 'Please enter a Boolean expression.';                return;            }                        // Simple expansion using distributive law            let expanded = expr                .replace(/A\.\(B\+C\)/g, '(A.B)+(A.C)')                .replace(/\(A\+B\)\.C/g, '(A.C)+(B.C)')                .replace(/A\+\(B\.C\)/g, '(A+B).(A+C)');                        result.textContent = `Original: ${expr}\nExpanded: ${expanded}`;        }        function convertToSOP() {            const expr = document.getElementById('boolean-input').value;            const result = document.getElementById('boolean-result');            result.textContent = `Converting to Sum of Products:\n${expr}\n\nSOP form requires truth table analysis.`;        }        function convertToPOS() {            const expr = document.getElementById('boolean-input').value;            const result = document.getElementById('boolean-result');            result.textContent = `Converting to Product of Sums:\n${expr}\n\nPOS form requires truth table analysis.`;        }        function showDeMorganLaw() {            const result = document.getElementById('laws-result');            result.textContent = `De Morgan's Laws:1. (A + B)' = A' . B'2. (A . B)' = A' + B'Example:(A + B + C)' = A' . B' . C'(A . B . C)' = A' + B' + C'`;        }        function showDistributiveLaw() {            const result = document.getElementById('laws-result');            result.textContent = `Distributive Laws:1. A + (B . C) = (A + B) . (A + C)2. A . (B + C) = (A . B) + (A . C)Example:X + (Y . Z) = (X + Y) . (X + Z)X . (Y + Z) = (X . Y) + (X . Z)`;        }        function showAbsorptionLaw() {            const result = document.getElementById('laws-result');            result.textContent = `Absorption Laws:1. A + (A . B) = A2. A . (A + B) = AExample:X + (X . Y) = XX . (X + Y) = X`;        }        function showIdentityLaws() {            const result = document.getElementById('laws-result');            result.textContent = `Identity Laws:1. A + 0 = A2. A . 1 = A3. A + 1 = 14. A . 0 = 05. A + A = A6. A . A = A7. A + A' = 18. A . A' = 0`;        }        function evaluateExpression() {            const expr = document.getElementById('eval-expression').value;            const result = document.getElementById('eval-result');                        const a = document.getElementById('var-a').checked;            const b = document.getElementById('var-b').checked;            const c = document.getElementById('var-c').checked;            const d = document.getElementById('var-d').checked;                        try {                // Simple expression evaluator                let evalExpr = expr                    .replace(/A/g, a ? '1' : '0')                    .replace(/B/g, b ? '1' : '0')                    .replace(/C/g, c ? '1' : '0')                    .replace(/D/g, d ? '1' : '0')                    .replace(/\+/g, '|')                    .replace(/\./g, '&')                    .replace(/'/g, '!');                                // This is a simplified evaluator                result.textContent = `Expression: ${expr}Variables: A=${a?1:0}, B=${b?1:0}, C=${c?1:0}, D=${d?1:0}Result: Evaluation requires proper Boolean parser`;            } catch (error) {                result.textContent = 'Error evaluating expression';            }        }        function generateTruthTable() {            const expr = document.getElementById('eval-expression').value;            const result = document.getElementById('eval-result');                        if (!expr.trim()) {                result.textContent = 'Please enter an expression first.';                return;            }                        // Extract variables from expression            const vars = [...new Set(expr.match(/[A-D]/g) || [])].sort();            const numVars = vars.length;            const numRows = Math.pow(2, numVars);                        let table = 'Truth Table:\n';            table += vars.join('\t') + '\tOutput\n';            table += '-'.repeat((numVars + 1) * 8) + '\n';                        for (let i = 0; i < numRows; i++) {                let row = '';                const values = [];                                for (let j = 0; j < numVars; j++) {                    const value = (i >> (numVars - 1 - j)) & 1;                    values.push(value);                    row += value + '\t';                }                                // Simplified output calculation                row += '?\t'; // Placeholder for actual calculation                table += row + '\n';            }                        result.textContent = table;        }        // K-Map Functions        function generateKMap() {            const vars = parseInt(document.getElementById('kmap-vars').value);            const container = document.getElementById('kmap-container');                        container.innerHTML = '';            container.className = `kmap-container kmap-${vars}var`;                        if (vars === 2) {                // 2-variable K-map                const labels = ['', 'A=0', 'A=1'];                const rowLabels = ['B=0', 'B=1'];                                // Headers                labels.forEach((label, i) => {                    const cell = document.createElement('div');                    cell.className = 'kmap-label';                    cell.textContent = label;                    container.appendChild(cell);                });                                // Rows                for (let row = 0; row < 2; row++) {                    const rowLabel = document.createElement('div');                    rowLabel.className = 'kmap-label';                    rowLabel.textContent = rowLabels[row];                    container.appendChild(rowLabel);                                        for (let col = 0; col < 2; col++) {                        const cell = document.createElement('div');                        cell.className = 'kmap-cell';                        cell.textContent = '0';                        cell.onclick = () => toggleKMapCell(cell);                        container.appendChild(cell);                    }                }            } else if (vars === 3) {                // 3-variable K-map implementation                const headers = ['', 'BC=00', 'BC=01', 'BC=11', 'BC=10'];                const rowLabels = ['A=0', 'A=1'];                                headers.forEach(header => {                    const cell = document.createElement('div');                    cell.className = 'kmap-label';                    cell.textContent = header;                    container.appendChild(cell);                });                                for (let row = 0; row < 2; row++) {                    const rowLabel = document.createElement('div');                    rowLabel.className = 'kmap-label';                    rowLabel.textContent = rowLabels[row];                    container.appendChild(rowLabel);                                        for (let col = 0; col < 4; col++) {                        const cell = document.createElement('div');                        cell.className = 'kmap-cell';                        cell.textContent = '0';                        cell.onclick = () => toggleKMapCell(cell);                        container.appendChild(cell);                    }                }            } else if (vars === 4) {                // 4-variable K-map implementation                const headers = ['', 'CD=00', 'CD=01', 'CD=11', 'CD=10'];                const rowLabels = ['AB=00', 'AB=01', 'AB=11', 'AB=10'];                                headers.forEach(header => {                    const cell = document.createElement('div');                    cell.className = 'kmap-label';                    cell.textContent = header;                    container.appendChild(cell);                });                                for (let row = 0; row < 4; row++) {                    const rowLabel = document.createElement('div');                    rowLabel.className = 'kmap-label';                    rowLabel.textContent = rowLabels[row];                    container.appendChild(rowLabel);                                        for (let col = 0; col < 4; col++) {                        const cell = document.createElement('div');                        cell.className = 'kmap-cell';                        cell.textContent = '0';                        cell.onclick = () => toggleKMapCell(cell);                        container.appendChild(cell);                    }                }            }        }        function toggleKMapCell(cell) {            if (cell.textContent === '0') {                cell.textContent = '1';                cell.classList.add('filled');            } else {                cell.textContent = '0';                cell.classList.remove('filled');            }        }        function solveKMap() {            const result = document.getElementById('kmap-result');            const vars = parseInt(document.getElementById('kmap-vars').value);            const cells = document.querySelectorAll('.kmap-cell');                        const ones = [];            cells.forEach((cell, index) => {                if (cell.textContent === '1') {                    ones.push(index);                }            });                        result.textContent = `K-Map Solution:Minterms: ${ones.join(', ')}Simplified expression: [Requires advanced algorithm]Prime implicants: [Analysis needed]`;        }        function clearKMap() {            const cells = document.querySelectorAll('.kmap-cell');            cells.forEach(cell => {                cell.textContent = '0';                cell.classList.remove('filled');            });        }        function generateFullTruthTable() {            const expr = document.getElementById('truth-expression').value;            const container = document.getElementById('truth-table-container');                        if (!expr.trim()) {                container.innerHTML = '<p>Please enter a Boolean expression.</p>';                return;            }                        const vars = [...new Set(expr.match(/[A-D]/g) || [])].sort();            const numVars = vars.length;            const numRows = Math.pow(2, numVars);                        let tableHTML = '<table class="truth-table"><thead><tr>';            vars.forEach(v => tableHTML += `<th>${v}</th>`);            tableHTML += '<th>Output</th></tr></thead><tbody>';                        for (let i = 0; i < numRows; i++) {                tableHTML += '<tr>';                for (let j = 0; j < numVars; j++) {                    const value = (i >> (numVars - 1 - j)) & 1;                    tableHTML += `<td>${value}</td>`;                }                tableHTML += '<td>?</td></tr>'; // Placeholder            }                        tableHTML += '</tbody></table>';            container.innerHTML = tableHTML;        }        // Event handlers and initialization        function setupEventListeners() {            // Drag and drop from component library            document.querySelectorAll('.component-item').forEach(item => {                item.addEventListener('dragstart', (e) => {                    e.dataTransfer.setData('text/plain', item.getAttribute('data-type'));                    item.classList.add('dragging');                });                                item.addEventListener('dragend', (e) => {                    item.classList.remove('dragging');                });            });            // Canvas events            canvas.addEventListener('dragover', (e) => e.preventDefault());            canvas.addEventListener('drop', handleDrop);            canvas.addEventListener('mousedown', handleMouseDown);            canvas.addEventListener('mousemove', handleMouseMove);            canvas.addEventListener('mouseup', handleMouseUp);            canvas.addEventListener('wheel', handleWheel);            canvas.addEventListener('contextmenu', (e) => e.preventDefault());            // Touch events for mobile            canvas.addEventListener('touchstart', handleTouchStart);            canvas.addEventListener('touchmove', handleTouchMove);            canvas.addEventListener('touchend', handleTouchEnd);            // Keyboard events            document.addEventListener('keydown', handleKeyDown);                        // Mode switching            document.querySelectorAll('.mode-btn').forEach(btn => {                btn.addEventListener('click', (e) => {                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));                    e.target.classList.add('active');                    currentMode = e.target.getAttribute('data-mode');                });            });        }        // Event handler implementations        function handleDrop(e) {            e.preventDefault();            const componentType = e.dataTransfer.getData('text/plain');            const rect = canvas.getBoundingClientRect();            const x = e.clientX - rect.left;            const y = e.clientY - rect.top;                        const gridPos = snapToGrid(x, y);            createComponent(componentType, gridPos.x, gridPos.y);            showToast(`${componentType} component added`, 'success');        }        function handleMouseDown(e) {            const rect = canvas.getBoundingClientRect();            const x = e.clientX - rect.left;            const y = e.clientY - rect.top;            // Check for connection points            const connectionPoint = getConnectionPointAt(x, y);            if (connectionPoint) {                if (isWireMode) {                    handleWireConnection(connectionPoint);                    return;                }            }            const component = getComponentAt(x, y);            if (component) {                // Handle component interaction                if (component.type === 'toggle' && !isWireMode) {                    component.state = !component.state;                    simulate();                    redraw();                    return;                }                                if (component.type === 'button' && !isWireMode) {                    component.pressed = true;                    simulate();                    redraw();return;                }                // Select component and start dragging                selectComponent(component);                isDragging = true;                dragOffset.x = x - (component.x * scale + panX);                dragOffset.y = y - (component.y * scale + panY);            } else {                // Deselect all components                components.forEach(comp => comp.selected = false);                selectedComponent = null;                updateProperties(null);                redraw();            }        }        function handleMouseMove(e) {            const rect = canvas.getBoundingClientRect();            const x = e.clientX - rect.left;            const y = e.clientY - rect.top;            if (isDragging && selectedComponent) {                const gridPos = snapToGrid(x - dragOffset.x, y - dragOffset.y);                selectedComponent.x = gridPos.x;                selectedComponent.y = gridPos.y;                simulate();                redraw();                updateProperties(selectedComponent);            }            // Update wire preview            if (isWireMode && wireStart) {                updateWirePreview(x, y);            }        }        function handleMouseUp(e) {            if (isDragging) {                isDragging = false;                saveState();            }        }        function handleWheel(e) {            e.preventDefault();            const rect = canvas.getBoundingClientRect();            const x = e.clientX - rect.left;            const y = e.clientY - rect.top;            const prevScale = scale;            scale *= e.deltaY > 0 ? 0.9 : 1.1;            scale = Math.max(0.2, Math.min(scale, 3));            // Zoom towards mouse position            const scaleChange = scale / prevScale;            panX = x - (x - panX) * scaleChange;            panY = y - (y - panY) * scaleChange;            drawGrid();            redraw();            updateZoomDisplay();        }        function handleKeyDown(e) {            if (e.key === 'Delete' && selectedComponent) {                deleteComponent(selectedComponent);                selectedComponent = null;                updateProperties(null);            }                        if (e.ctrlKey || e.metaKey) {                if (e.key === 'z') {                    e.preventDefault();                    undo();                }                if (e.key === 'y') {                    e.preventDefault();                    redo();                }                if (e.key === 's') {                    e.preventDefault();                    saveCircuit();                }            }            if (e.key === 'Escape') {                isWireMode = false;                wireStart = null;                wirePreview.style.display = 'none';                document.getElementById('wire-mode').classList.remove('active');            }        }        function handleTouchStart(e) {            e.preventDefault();            const touch = e.touches[0];            handleMouseDown({                clientX: touch.clientX,                clientY: touch.clientY            });        }        function handleTouchMove(e) {            e.preventDefault();            const touch = e.touches[0];            handleMouseMove({                clientX: touch.clientX,                clientY: touch.clientY            });        }        function handleTouchEnd(e) {            e.preventDefault();            handleMouseUp();        }        function getComponentAt(x, y) {            for (let i = components.length - 1; i >= 0; i--) {                const comp = components[i];                const compX = comp.x * scale + panX;                const compY = comp.y * scale + panY;                const compW = comp.width * scale;                const compH = comp.height * scale;                                if (x >= compX && x <= compX + compW && y >= compY && y <= compY + compH) {                    return comp;                }            }            return null;        }        function getConnectionPointAt(x, y) {            for (let comp of components) {                const type = componentTypes[comp.type];                const compX = comp.x * scale + panX;                const compY = comp.y * scale + panY;                const compW = comp.width * scale;                const compH = comp.height * scale;                // Check input points                for (let i = 0; i < type.inputs; i++) {                    const py = compY + (compH / (type.inputs + 1)) * (i + 1);                    const dist = Math.sqrt((x - compX) ** 2 + (y - py) ** 2);                    if (dist < 12 * scale) {                        return {                            componentId: comp.id,                            type: 'input',                            port: i,                            x: compX,                            y: py                        };                    }                }                // Check output points                for (let i = 0; i < type.outputs; i++) {                    const py = compY + (compH / (type.outputs + 1)) * (i + 1);                    const dist = Math.sqrt((x - (compX + compW)) ** 2 + (y - py) ** 2);                    if (dist < 12 * scale) {                        return {                            componentId: comp.id,                            type: 'output',                            port: i,                            x: compX + compW,                            y: py                        };                    }                }            }            return null;        }        function handleWireConnection(point) {            if (!wireStart) {                if (point.type === 'output') {                    wireStart = point;                    wirePreview.style.display = 'block';                    showToast('Select input to connect', 'info');                }            } else {                if (point.type === 'input' && point.componentId !== wireStart.componentId) {                    createWire(wireStart, point);                    wireStart = null;                    wirePreview.style.display = 'none';                } else {                    showToast('Invalid connection', 'error');                }            }        }        function createWire(from, to) {            // Check if wire already exists            const exists = wires.some(wire =>                wire.from.componentId === from.componentId &&                 wire.from.port === from.port &&                wire.to.componentId === to.componentId &&                 wire.to.port === to.port            );            if (exists) {                showToast('Wire already exists', 'error');                return;            }            const wire = {                id: wireIdCounter++,                from: {                    componentId: from.componentId,                    port: from.port                },                to: {                    componentId: to.componentId,                    port: to.port                }            };            wires.push(wire);            saveState();            simulate();            redraw();            showToast('Wire connected', 'success');        }        function updateWirePreview(x, y) {            if (!wireStart) return;                        const path = `M ${wireStart.x} ${wireStart.y} Q ${(wireStart.x + x) / 2} ${wireStart.y} ${x} ${y}`;            previewPath.setAttribute('d', path);        }        function selectComponent(comp) {            components.forEach(c => c.selected = false);            comp.selected = true;            selectedComponent = comp;            updateProperties(comp);            redraw();        }        // Toolbar functions        function clearCanvas() {            if (confirm('Clear all components and wires?')) {                components.forEach(comp => {                    if (comp.clockInterval) clearInterval(comp.clockInterval);                    if (comp.pulseInterval) clearInterval(comp.pulseInterval);                });                components.length = 0;                wires.length = 0;                selectedComponent = null;                updateProperties(null);                saveState();                redraw();                showToast('Canvas cleared', 'success');            }        }        function toggleWireMode() {            isWireMode = !isWireMode;            const btn = document.getElementById('wire-mode');            if (isWireMode) {                btn.classList.add('active');                canvas.style.cursor = 'crosshair';                showToast('Wire mode enabled - Click output then input', 'info');            } else {                btn.classList.remove('active');                canvas.style.cursor = 'default';                wireStart = null;                wirePreview.style.display = 'none';            }        }        function toggleSelectMode() {            isWireMode = false;            wireStart = null;            wirePreview.style.display = 'none';            canvas.style.cursor = 'default';            document.getElementById('wire-mode').classList.remove('active');            document.getElementById('select-mode').classList.add('active');        }        function zoomIn() {            scale *= 1.2;            scale = Math.min(scale, 3);            drawGrid();            redraw();            updateZoomDisplay();        }        function zoomOut() {            scale *= 0.8;            scale = Math.max(scale, 0.2);            drawGrid();            redraw();            updateZoomDisplay();        }        function resetZoom() {            scale = 1;            panX = 0;            panY = 0;            drawGrid();            redraw();            updateZoomDisplay();        }        function updateZoomDisplay() {            document.getElementById('zoom-level').textContent = Math.round(scale * 100) + '%';        }        // Simulation functions        function runSimulation() {            if (simulationRunning) {                simulationRunning = false;                showToast('Simulation stopped', 'info');                return;            }            simulationRunning = true;            showToast('Simulation started', 'success');                        const simulationInterval = setInterval(() => {                if (!simulationRunning) {                    clearInterval(simulationInterval);                    return;                }                simulate();                redraw();            }, simulationSpeed);        }        function stepSimulation() {            simulate();            redraw();            showToast('Simulation stepped', 'info');        }        function resetSimulation() {            simulationRunning = false;            components.forEach(comp => {                comp.inputValues.fill(false);                comp.lastOutputs.fill(false);                comp.lastClock = false;                comp.count = 0;            });            simulate();            redraw();            showToast('Simulation reset', 'success');        }        // State management        function saveState() {            const state = {                components: JSON.parse(JSON.stringify(components)),                wires: JSON.parse(JSON.stringify(wires))            };                        undoStack.push(state);            if (undoStack.length > maxUndoSteps) {                undoStack.shift();            }            redoStack.length = 0;        }        function undo() {            if (undoStack.length === 0) return;                        const currentState = {                components: JSON.parse(JSON.stringify(components)),                wires: JSON.parse(JSON.stringify(wires))            };            redoStack.push(currentState);                        const prevState = undoStack.pop();            restoreState(prevState);            showToast('Undone', 'info');        }        function redo() {            if (redoStack.length === 0) return;                        const currentState = {                components: JSON.parse(JSON.stringify(components)),                wires: JSON.parse(JSON.stringify(wires))            };            undoStack.push(currentState);                        const nextState = redoStack.pop();            restoreState(nextState);            showToast('Redone', 'info');        }        function restoreState(state) {            // Clear existing intervals            components.forEach(comp => {                if (comp.clockInterval) clearInterval(comp.clockInterval);                if (comp.pulseInterval) clearInterval(comp.pulseInterval);            });                        components = state.components;            wires = state.wires;                        // Restore intervals for clock components            components.forEach(comp => {                if (comp.type === 'clock' && !comp.clockInterval) {                    comp.clockInterval = setInterval(() => {                        comp.clockState = !comp.clockState;                        simulate();                        redraw();                    }, 1000);                }                if (comp.type === 'pulse' && !comp.pulseInterval) {                    comp.pulseInterval = setInterval(() => {                        comp.pulseState = !comp.pulseState;                        simulate();                        redraw();                    }, 500);                }            });                        simulate();            redraw();        }        // File operations        function saveCircuit() {            const circuitData = {                components: components,                wires: wires,                timestamp: new Date().toISOString(),                version: '1.0'            };                        const dataStr = JSON.stringify(circuitData, null, 2);            const dataBlob = new Blob([dataStr], { type: 'application/json' });                        const link = document.createElement('a');            link.href = URL.createObjectURL(dataBlob);            link.download = 'circuit.json';            link.click();                        showToast('Circuit saved', 'success');        }        function loadCircuit() {            const input = document.createElement('input');            input.type = 'file';            input.accept = '.json';            input.onchange = (e) => {                const file = e.target.files[0];                if (!file) return;                                const reader = new FileReader();                reader.onload = (e) => {                    try {                        const circuitData = JSON.parse(e.target.result);                                                // Clear current circuit                        components.forEach(comp => {                            if (comp.clockInterval) clearInterval(comp.clockInterval);                            if (comp.pulseInterval) clearInterval(comp.pulseInterval);                        });                                                components = circuitData.components || [];                        wires = circuitData.wires || [];                                                // Restore component intervals                        components.forEach(comp => {                            if (comp.type === 'clock') {                                comp.clockInterval = setInterval(() => {                                    comp.clockState = !comp.clockState;                                    simulate();                                    redraw();                                }, 1000);                            }                            if (comp.type === 'pulse') {                                comp.pulseInterval = setInterval(() => {                                    comp.pulseState = !comp.pulseState;                                    simulate();                                    redraw();                                }, 500);                            }                        });                                                // Update counters                        componentIdCounter = Math.max(...components.map(c => c.id), 0) + 1;                        wireIdCounter = Math.max(...wires.map(w => w.id), 0) + 1;                                                saveState();                        simulate();                        redraw();                        showToast('Circuit loaded', 'success');                                            } catch (error) {                        showToast('Error loading circuit file', 'error');                        console.error('Load error:', error);                    }                };                reader.readAsText(file);            };            input.click();        }        function exportTruthTable() {            const expr = document.getElementById('truth-expression').value;            if (!expr.trim()) {                showToast('Please enter an expression first', 'error');                return;            }                        const vars = [...new Set(expr.match(/[A-D]/g) || [])].sort();            const numVars = vars.length;            const numRows = Math.pow(2, numVars);                        let csv = vars.join(',') + ',Output\n';                        for (let i = 0; i < numRows; i++) {                const row = [];                for (let j = 0; j < numVars; j++) {                    const value = (i >> (numVars - 1 - j)) & 1;                    row.push(value);                }                row.push('?'); // Placeholder                csv += row.join(',') + '\n';            }                        const blob = new Blob([csv], { type: 'text/csv' });            const link = document.createElement('a');            link.href = URL.createObjectURL(blob);            link.download = 'truth_table.csv';            link.click();                        showToast('Truth table exported', 'success');        }        function importTruthTable() {            showToast('Truth table import functionality not yet implemented', 'info');        }        function findPrimeImplicants() {            const result = document.getElementById('implicants-result');            result.textContent = 'Prime implicant calculation requires advanced Quine-McCluskey algorithm implementation.';        }        function findEssentialImplicants() {            const result = document.getElementById('implicants-result');            result.textContent = 'Essential prime implicant calculation requires advanced algorithm implementation.';        }        function fillFromTruthTable() {            showToast('K-Map filling from truth table not yet implemented', 'info');        }        // Initialize the application        function init() {            initCanvas();            setupEventListeners();            generateKMap();                        // Initialize zoom display            updateZoomDisplay();                        // Initialize first save state            saveState();                        showToast('CircuitPro Advanced loaded successfully!', 'success');            console.log('CircuitPro Advanced initialized');        }        // Start the application when DOM is ready        if (document.readyState === 'loading') {            document.addEventListener('DOMContentLoaded', init);        } else {            init();        }    </script>    <!-- Add your existing JavaScript here -->    <script>        // Add a simple toggle function for mobile sidebar        function toggleSidebar() {            const sidebar = document.getElementById('sidebar');            const isMobile = window.innerWidth <= 768;                        if (isMobile) {                sidebar.classList.toggle('open');            }        }                // Add a simple toggle function for properties panel        function toggleProperties() {            const panel = document.getElementById('properties-panel');            panel.classList.toggle('open');        }                // Placeholder functions for tab switching and section toggling        function switchTab(tabName) {            // Hide all tab contents            document.querySelectorAll('.tab-content').forEach(tab => {                tab.style.display = 'none';            });                        // Remove active class from all tabs            document.querySelectorAll('.sidebar-tab').forEach(tab => {                tab.classList.remove('active');            });                        // Show selected tab            const selectedTab = document.getElementById(tabName + '-tab');            if (selectedTab) {                selectedTab.style.display = 'block';            }                        // Add active class to clicked tab            event.target.classList.add('active');        }                function toggleSection(sectionId) {            const content = document.getElementById(sectionId + '-content');            const arrow = document.getElementById(sectionId + '-arrow');            const header = arrow.closest('.section-header');                        if (content && header) {                content.classList.toggle('collapsed');                header.classList.toggle('collapsed');            }        }                // Ensure sidebar stays visible on desktop        function handleResize() {            const sidebar = document.getElementById('sidebar');            const isDesktop = window.innerWidth > 768;                        if (isDesktop) {                sidebar.classList.remove('open');                sidebar.classList.add('sidebar-visible');            } else {                sidebar.classList.remove('sidebar-visible');            }        }                // Initialize on page load        window.addEventListener('load', function() {            handleResize();        });                window.addEventListener('resize', function() {            handleResize();        });                // Placeholder for your existing script functions        // Insert your original JavaScript functions here, replacing the placeholders above                console.log('CircuitPro Advanced UI Framework Ready');    </script>